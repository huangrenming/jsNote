函数形成一个新的私有的作用域保护了里面的私有变量不受外界的干扰(外面修改不了私有的,私有的也修改不了外面的)-->"闭包"

预解释是毫无节操的一种机制

1、预解释的时候不管你的条件是否成立,都要把带var的进行提前的声明
   window的预解释:var num; -> window.num;

2、预解释的时候只预解释"="左边的,右边的是值,不参与预解释
    匿名函数之函数表达式:把函数定义的部分当做一个值赋值给我们的变量/元素的某一个事件
    window下的预解释:var fn;

3、执行函数定义的那个function在全局作用域下不进行预解释,当代码执行到这个位置的时候定义和执行一起完成了
    自执行函数：定义和执行一起完成了

4、函数体中return下面的代码虽然不在执行了,但是需要进行预解释;return后面跟着的都是我们返回的值,所以不进行预解释;

5、在预解释的时候,如果名字已经声明过了,不需要从新的声明,但是需要重新的赋值;
    在JS中如果变量的名字和函数的名字重复了,也算冲突

window预解释:
    //声明+定义 fn=xxxfff111
    //声明 var fn; (不需要重新声明)
    //声明(不重复进行)+定义 fn=xxxfff222
    //->fn=xxxfff222


3、JS中内存的分类
    栈内存:用来提供一个供JS代码执行的环境 ->作用域(全局作用域/私有的作用域)
    堆内存:用来存储引用数据类型的值 ->对象存储的是属性名和属性值,函数存储的是代码字符串...

如何查找当前作用域的上一级作用域?
    看当前函数是在哪个作用域下定义的,那么它的上级作用域就是谁->和函数在哪执行的没有任何的关系

js的内存释放？？

堆内存
    对象数据类型或者函数数据类型在定义的时候首先都会开辟一个堆内存,堆内存有一个引用的地址,如果外面有变量等知道了这个地址,我们就说这个内存被占用了,就不能销毁了
        var obj1 = {name: "张三"};
        var obj2 = obj1;
        //我们想要让堆内存释放/销毁,只需要把所有引用它的变量值赋值为null即可，如果当前的堆内存没有任何东西被占用了,那么浏览器会在空闲的时候把它销毁...
        obj1 = null;
        obj2 = null;

栈内存
    1)全局作用域
      只有当页面关闭的时候全局作用域才会销毁

    2)私有的作用域(只有函数执行会产生私有的作用域)
      一般情况下,函数执行会形成一个新的私有的作用域,当私有作用域中的代码执行完成后,我们当前作用域都会主动的进行释放和销毁
      但是还是存在特殊的情况的:
      当前私有作用域中的部分内存被作用域以外的东西占用了,那么当前的这个作用域就不能销毁了
      a、函数执行返回了一个引用数据类型的值,并且在函数的外面被一个其他的东西给接收了,这种情况下一般形成的私有作用域都不会销毁
        function fn() {
            var num = 100;
            return function () {

            }
        }
        var f = fn();//fn执行形成的这个私有的作用域就不能再销毁了

    b、在一个私有的作用域中给DOM元素的事件绑定方法,一般情况下我们的私有作用域都不销毁
        var oDiv = document.getElementById("div1");
        ~function () {
            oDiv.onclick = function () {

            }
        }();//当前自执行函数形成的这个私有的作用域也不销毁

    c、下述情况属于不立即销毁->fn返回的函数没有被其他的东西占用,但是还需要执行一次呢,所以暂时不销毁,当返回的值执行完成后,浏览器会在空闲的时候把它销毁了 ->"不立即销毁"
        function fn() {
            var num = 100;
            return function () {

            }
        }
        fn()();//首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行